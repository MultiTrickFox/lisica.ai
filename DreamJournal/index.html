<html>

<head>
    <title>DreamJournal</title>
    <link rel="icon" type="image/x-icon" href="favicon.png">
</head>

<body style="
    background-color: black;
    margin: 0;
    overflow-y: scroll;
    cursor: auto;
    -webkit-user-select: none;
    ">
    <link rel="stylesheet" href="style.css">

    <script>

        const canvas = document.createElement("canvas")
        document.body.appendChild(canvas)
        canvas.width = document.body.clientWidth 
        canvas.height = document.body.clientHeight
        const ctx  = canvas.getContext("2d")

        const upper_textbox = document.createElement("div")
        document.body.appendChild(upper_textbox)
        upper_textbox.style.position = 'absolute'
        upper_textbox.style.top = '33%'
        upper_textbox.style.left = '50%'
        upper_textbox.style.transform = 'translate(-50%, -50%)'
        upper_textbox.style.backgroundColor = 'rgba(0, 0, 0, 0.2)'
        upper_textbox.style.color = 'white'
        upper_textbox.style.fontFamily = 'Quicksand'
        upper_textbox.style.fontSize = '14pt'
        upper_textbox.style.textAlign = 'center'
        upper_textbox.style.border = 'none'
        upper_textbox.style.outline = 'none'
        upper_textbox.style.padding = '10px'
        //upper_textbox.textContent = 'Hello there'


    </script>

    <script>

        var is_request_running

        const sleep = sec => new Promise(r => setTimeout(r, sec*1_000))

        async function fetch_dreams() {

            if (is_request_running) return
            else is_request_running = true
            document.body.style.cursor = 'wait'

            let xhr = new XMLHttpRequest()
            let response = null
            xhr.open("GET", 'https://lisica.lisica.ai:64243/dreamjournal', true)
            xhr.setRequestHeader("cmd", "dreams")
            xhr.onreadystatechange = function() {
                if (xhr.readyState == XMLHttpRequest.DONE) {
                    let result = JSON.parse(xhr.responseText)
                    response = result.answer
                    console.log('response received:',response)
                }
            }
            xhr.send()
            while (response == null) await sleep(.1)

            is_request_running = false
            document.body.style.cursor = 'auto'
            return response

        }

        async function fetch_until() {

            // if (is_request_running) return
            // else is_request_running = true
            //document.body.style.cursor = 'wait'

            let xhr = new XMLHttpRequest()
            let response = null
            xhr.open("GET", 'https://lisica.lisica.ai:64243/dreamjournal', true)
            xhr.setRequestHeader("cmd", "until")
            xhr.onreadystatechange = function() {
                if (xhr.readyState == XMLHttpRequest.DONE) {
                    let result = JSON.parse(xhr.responseText)
                    response = result.answer
                    console.log('response received:',response)
                }
            }
            xhr.send()
            while (response == null) await sleep(.1)

            // is_request_running = false
            //document.body.style.cursor = 'auto'
            return response

        }

        async function fetch_search(text) {

            if (is_request_running) return
            else is_request_running = true
            document.body.style.cursor = 'wait'

            let xhr = new XMLHttpRequest()
            let response = null
            xhr.open("GET", 'https://lisica.lisica.ai:64243/dreamjournal', true)
            xhr.setRequestHeader("cmd", "until")
            xhr.setRequestHeader("text", text)
            xhr.onreadystatechange = function() {
                if (xhr.readyState == XMLHttpRequest.DONE) {
                    let result = JSON.parse(xhr.responseText)
                    response = result.answer
                    console.log('response received:',response)
                }
            }
            xhr.send()
            while (response == null) await sleep(.1)

            is_request_running = false
            document.body.style.cursor = 'auto'
            return response

        }

    </script>

    <script>

        var dreams

        async function auto_fetch_dreams() {
            while (true) {
                await sleep(((await fetch_until())+1)*60)
                dreams = await fetch_dreams()
            }
        }

        auto_fetch_dreams()

        var until_next_dream

        async function auto_fetch_until() {
            while (true) {
                await sleep(1*60)
                until_next_dream = await fetch_until()
            }
        }

        auto_fetch_until()

    </script>

    <script>

        async function main() {

            dreams = await fetch_dreams()

            let dream_ids = Object.keys(dreams)
            console.log('dream_ids:',dream_ids)

            let dream_id = dream_ids[Math.floor(Math.random()*dream_ids.length)]
            console.log('dream_id:',dream_id)

            let dream = dreams[dream_id]
            let chunks = dream['chunks']
            let images = dream['images']

            for (let i = 0; i < chunks.length; i++) {
                let chunk = chunks[i]
                let image = images[i]



                // TODO: split the text into two main chunks

                // start writing the upper chunk

                // the image appears on the middle (in a circularly edge blackened way, flickering dark pixels)

                // then comes the bottom chunk





                const img = new Image()        
                img.src = 'data:image/png;base64,'+image
                img.onload = function() {
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height)

                    ctx.drawImage(img, canvas.width/2-img.width/2, canvas.height/2-img.height/2)

                    let punto = 16
                    
                    upper_textbox.style.font = '${punto}px Quicksand'

                    upper_textbox.textContent = chunk

                    // ctx.font = `${punto}px Quicksand`
                    // ctx.fillStyle = 'white'
                    // ctx.textAlign = 'center'
                    // ctx.textBaseline = 'middle'

                    // let thresholdWidth = img.width / 2

                    // let words = chunk.split(" ")
                    // let line = ""
                    // let lines = []
                    // let lineCount = 0

                    // for (let i = 0; i < words.length; i++) {
                    //     let testLine = line + words[i] + " "
                    //     let testLineWidth = ctx.measureText(testLine).width
                    //     if (testLineWidth > thresholdWidth) {
                    //         lines.push(line.trim())
                    //         line = words[i] + " "
                    //         lineCount++
                    //     } else {
                    //         line = testLine
                    //     }
                    // }

                    // if (line.trim().length > 0) {
                    //     lines.push(line.trim())
                    //     lineCount++
                    // }

                    // let x = canvas.width / 2
                    // let y = canvas.height / 2 - ((lineCount - 1) * punto / 2)

                    // for (let i = 0; i < lines.length; i++) {
                    //     const textY = y + (i * punto)
                    //     ctx.fillText(lines[i], x, textY)
                    // }

                }

                await sleep(.06 * chunk.length)

            }

        }

        main()

    </script>

    <script>

        

    </script>

</body>
</html>







