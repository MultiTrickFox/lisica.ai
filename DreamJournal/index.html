<html>

<head>
    <title>DreamJournal</title>
    <link rel="icon" type="image/x-icon" href="favicon.png">
</head>

<body style="
    background-color: black;
    margin: 0;
    overflow-y: scroll;
    cursor: auto;
    -webkit-user-select: none;
    ">

    <script>

        // UI elements

        const canvas = document.createElement("canvas")
        document.body.appendChild(canvas)
        canvas.width = document.body.clientWidth 
        canvas.height = document.body.clientHeight
        const ctx  = canvas.getContext("2d")

    </script>

    <script>

        var is_request_running

        const sleep = sec => new Promise(r => setTimeout(r, sec*1_000))

        async function fetch_dreams() {

            if (is_request_running) return
            else is_request_running = true
            document.body.style.cursor = 'wait'

            let xhr = new XMLHttpRequest()
            let response = null
            xhr.open("GET", 'https://lisica.lisica.ai:64243/dreamjournal', true)
            xhr.setRequestHeader("cmd", "dreams")
            xhr.onreadystatechange = function() {
                if (xhr.readyState == XMLHttpRequest.DONE) {
                    let result = JSON.parse(xhr.responseText)
                    response = result.answer
                    console.log('response received:',response)
                }
            }
            xhr.send()
            while (response == null) await sleep(.1)

            is_request_running = false
            document.body.style.cursor = 'auto'
            return response

        }

        async function fetch_until() {

            // if (is_request_running) return
            // else is_request_running = true
            //document.body.style.cursor = 'wait'

            let xhr = new XMLHttpRequest()
            let response = null
            xhr.open("GET", 'https://lisica.lisica.ai:64243/dreamjournal', true)
            xhr.setRequestHeader("cmd", "until")
            xhr.onreadystatechange = function() {
                if (xhr.readyState == XMLHttpRequest.DONE) {
                    let result = JSON.parse(xhr.responseText)
                    response = result.answer
                    console.log('response received:',response)
                }
            }
            xhr.send()
            while (response == null) await sleep(.1)

            // is_request_running = false
            //document.body.style.cursor = 'auto'
            return response

        }

        async function fetch_search(text) {

            if (is_request_running) return
            else is_request_running = true
            document.body.style.cursor = 'wait'

            let xhr = new XMLHttpRequest()
            let response = null
            xhr.open("GET", 'https://lisica.lisica.ai:64243/dreamjournal', true)
            xhr.setRequestHeader("cmd", "until")
            xhr.setRequestHeader("text", text)
            xhr.onreadystatechange = function() {
                if (xhr.readyState == XMLHttpRequest.DONE) {
                    let result = JSON.parse(xhr.responseText)
                    response = result.answer
                    console.log('response received:',response)
                }
            }
            xhr.send()
            while (response == null) await sleep(.1)

            is_request_running = false
            document.body.style.cursor = 'auto'
            return response

        }

    </script>

    <script>

        async function main() {

            let dreams = await fetch_dreams()

            //console.log(dreams)
            //console.log(dreams['2023-04-12 21:12:35.340700'])

            let dream_ids = Object.keys(dreams)
            console.log('dream_ids:',dream_ids)

            let dream_id = dream_ids[Math.floor(Math.random()*dream_ids.length)]
            console.log('dream_id:',dream_id)

            let dream = dreams[dream_id]
            let chunks = dream['chunks']
            let images = dream['images']
            
            // for (let i = 0; i < chunks.length; i++) {
            //     alert(chunks[i])                
            // }

            for (let i = 0; i < chunks.length; i++) {

                let chunk = chunks[i]
                let image = images[i]

                const img = new Image()        
                img.src = 'data:image/png;base64,'+image
                img.onload = function() {
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height)
                    // ctx.fillStyle = 'black'
                    // ctx.fillRect(0, 0, canvas.width, canvas.height)

                    let x = canvas.width / 2 - img.width / 2
                    let y = canvas.height / 2 - img.height / 2
                    ctx.drawImage(img, x, y)

                    let punto = 16
                    ctx.font = `${punto}px Quicksand`
                    ctx.fillStyle = 'white'
                    ctx.textAlign = 'center'
                    ctx.textBaseline = 'middle'

                    let thresholdWidth = img.width / 2

                    let words = chunk.split(" ")
                    let line = ""
                    let lines = []
                    let lineCount = 0

                    for (let i = 0; i < words.length; i++) {
                        let testLine = line + words[i] + " "
                        let testLineWidth = ctx.measureText(testLine).width
                        if (testLineWidth > thresholdWidth) {
                            lines.push(line.trim())
                            line = words[i] + " "
                            lineCount++
                        } else {
                            line = testLine
                        }
                    }

                    if (line.trim().length > 0) {
                        lines.push(line.trim())
                        lineCount++
                    }

                    x = canvas.width / 2
                    y = canvas.height / 2 - ((lineCount - 1) * punto / 2)

                    for (let i = 0; i < lines.length; i++) {
                        const textY = y + (i * punto)
                        ctx.fillText(lines[i], x, textY)
                    }

                }

                await sleep(12)

            }


        }

    </script>

    <script>

        main()

    </script>

</body>
</html>







