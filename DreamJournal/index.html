<html>

<head>
    <title>DreamJournal</title>
    <link rel="icon" type="image/x-icon" href="favicon.png">
</head>

<body style="
    background-color: black;
    margin: 0;
    overflow-y: scroll;
    cursor: auto;
    -webkit-user-select: none;
    ">
    <link rel="stylesheet" href="style.css">

    <script>

        var is_request_running

        const sleep = sec => new Promise(r => setTimeout(r, sec*1_000))

        async function fetch_dreams() {

            if (is_request_running) return
            else is_request_running = true
            document.body.style.cursor = 'wait'

            let xhr = new XMLHttpRequest()
            let response = null
            xhr.open("GET", 'https://lisica.lisica.ai:64243/dreamjournal', true)
            xhr.setRequestHeader("cmd", "dreams")
            xhr.onreadystatechange = function() {
                if (xhr.readyState == XMLHttpRequest.DONE) {
                    let result = JSON.parse(xhr.responseText)
                    response = result.answer
                    console.log('response received:',response)
                }
            }
            xhr.send()
            while (response == null) await sleep(.1)

            is_request_running = false
            document.body.style.cursor = 'auto'
            return response

        }

        async function fetch_until() {

            // if (is_request_running) return
            // else is_request_running = true
            //document.body.style.cursor = 'wait'

            let xhr = new XMLHttpRequest()
            let response = null
            xhr.open("GET", 'https://lisica.lisica.ai:64243/dreamjournal', true)
            xhr.setRequestHeader("cmd", "until")
            xhr.onreadystatechange = function() {
                if (xhr.readyState == XMLHttpRequest.DONE) {
                    let result = JSON.parse(xhr.responseText)
                    response = result.answer
                    console.log('response received:',response)
                }
            }
            xhr.send()
            while (response == null) await sleep(.1)

            // is_request_running = false
            //document.body.style.cursor = 'auto'
            return response

        }

        async function fetch_search(text) {

            if (is_request_running) return
            else is_request_running = true
            document.body.style.cursor = 'wait'

            let xhr = new XMLHttpRequest()
            let response = null
            xhr.open("GET", 'https://lisica.lisica.ai:64243/dreamjournal', true)
            xhr.setRequestHeader("cmd", "until")
            xhr.setRequestHeader("text", text)
            xhr.onreadystatechange = function() {
                if (xhr.readyState == XMLHttpRequest.DONE) {
                    let result = JSON.parse(xhr.responseText)
                    response = result.answer
                    console.log('response received:',response)
                }
            }
            xhr.send()
            while (response == null) await sleep(.1)

            is_request_running = false
            document.body.style.cursor = 'auto'
            return response

        }

    </script>

    <script>

        var dreams

        async function auto_fetch_dreams() {
            while (true) {
                await sleep(((await fetch_until())+1)*60)
                dreams = await fetch_dreams()
            }
        }

        auto_fetch_dreams()

        var until_next_dream

        async function auto_fetch_until() {
            while (true) {
                await sleep(1*60)
                until_next_dream = await fetch_until()
            }
        }

        auto_fetch_until()

    </script>

    <script>

        const canvas = document.createElement("canvas")
        document.body.appendChild(canvas)
        canvas.width = document.body.clientWidth 
        canvas.height = document.body.clientHeight
        const ctx = canvas.getContext("2d")

        const canvas_noise = document.createElement("canvas")
        document.body.appendChild(canvas_noise)
        canvas_noise.width = document.body.clientWidth 
        canvas_noise.height = document.body.clientHeight
        const ctx_noise = canvas_noise.getContext("2d")

        const upper_textbox = document.createElement("div")
        document.body.appendChild(upper_textbox)
        upper_textbox.style.position = 'absolute'
        upper_textbox.style.top = '33%'
        upper_textbox.style.left = '50%'
        upper_textbox.style.transform = 'translate(-50%, -50%)'
        upper_textbox.style.backgroundColor = 'rgba(0, 0, 0, 0.2)'
        upper_textbox.style.color = 'white'
        upper_textbox.style.fontFamily = 'Quicksand'
        upper_textbox.style.fontSize = '14pt'
        upper_textbox.style.textAlign = 'center'
        upper_textbox.style.border = 'none'
        upper_textbox.style.outline = 'none'
        upper_textbox.style.padding = '10px'
        //upper_textbox.textContent = 'Hello there'

        const lower_textbox = document.createElement("div")
        document.body.appendChild(lower_textbox)
        lower_textbox.style.position = 'absolute'
        lower_textbox.style.bottom = '33%'
        lower_textbox.style.left = '50%'
        lower_textbox.style.transform = 'translate(-50%, -50%)'
        lower_textbox.style.backgroundColor = 'rgba(0, 0, 0, 0.2)'
        lower_textbox.style.color = 'white'
        lower_textbox.style.fontFamily = 'Quicksand'
        lower_textbox.style.fontSize = '14pt'
        lower_textbox.style.textAlign = 'center'
        lower_textbox.style.border = 'none'
        lower_textbox.style.outline = 'none'
        lower_textbox.style.padding = '10px'
        //lower_textbox.textContent = 'Hello there'

    </script>

    <script src='perlin.js'></script>

    <script>


        // create an independent fn for perlin field here that updates 2nd canvas every n seconds
        
        var perlin_time = 2

        function apply_perlin_mist() {

            perlin_time +=1/100

            image = ctx_noise.getImageData(0, 0, canvas_noise.width, canvas_noise.height)
            pixels = image.data

            for (let x = 0; x < canvas_noise.width; x+=4) {
                for (let y = 0; y < canvas_noise.height; y+=4) {

                    let value = noise.simplex3(x / 100, y / 100, perlin_time)
                    value = Math.abs(value) * 256

                    var cell = (x + y * canvas_noise.width) * 4
                    pixels[cell] = pixels[cell+1] = pixels[cell+2] = value
                    pixels[cell+3] = 255 // alpha.

                }
            }

            ctx_noise.putImageData(image, 0, 0)

        }

        setInterval(apply_perlin_mist, 60)

        







        async function play_a_dream() {

            dreams = await fetch_dreams()

            let dream_ids = Object.keys(dreams)
            
            let dream_id = dream_ids[Math.floor(Math.random()*dream_ids.length)]

            let dream = dreams[dream_id]
            let chunks = dream['chunks']
            let images = dream['images']

            for (let i = 0; i < chunks.length; i++) {
                let chunk = chunks[i]
                let image = images[i]


                // TODO: split the text into two main chunks

                // start writing the upper chunk

                // the image appears on the middle (in a circularly edge blackened way, flickering dark pixels)

                // then comes the bottom chunk


                    const img = new Image()        
                    img.src = 'data:image/png;base64,'+image
                    img.onload = function() {
                        
                        ctx.clearRect(0, 0, canvas.width, canvas.height)
                        ctx.drawImage(img, (canvas.width-img.width)/2, (canvas.height-img.height)/2)

                        upper_textbox.style.font = '${16}px Quicksand'
                        upper_textbox.textContent = chunk

                        ctx.globalCompositeOperation = 'multiply'
                        ctx.drawImage(canvas_noise, 0, 0)

                    }

                await sleep(.06 * chunk.length)

            }

        }

        play_a_dream()

    </script>

    <script>

        

    </script>

</body>
</html>







